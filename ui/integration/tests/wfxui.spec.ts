// SPDX-FileCopyrightText: 2025 Siemens AG
//
// SPDX-License-Identifier: Apache-2.0
//
// Author: Michael Adler <michael.adler@siemens.com>

import { test, expect } from "@playwright/test";
import { createJob, createWorkflow, deleteJob, deleteWorkflow } from "./helper";

const baseUrl = "http://localhost:8081";
const uiBaseUrl = baseUrl + "/ui";

test("empty jobs table", async ({ page }) => {
  await page.goto(uiBaseUrl);

  // Wait for table to appear
  await page.locator("#jobs-table").waitFor();

  const rows = page.locator("#jobs-table> tbody > tr");
  const texts = await rows.allTextContents();
  expect(texts).toEqual([]);

  await expect(rows).toHaveCount(0);
});

test("empty workflows table", async ({ page }) => {
  await page.goto(uiBaseUrl);

  const workflowsLink = page.getByRole("link", { name: "Workflows" });
  await workflowsLink.click();

  // Wait for table to appear
  await page.locator("#workflows-table").waitFor();

  const rows = page.locator("#workflows-table > tbody > tr");
  const texts = await rows.allTextContents();
  expect(texts).toEqual([]);

  await expect(rows).toHaveCount(0);
});

test("non-empty workflows table", async ({ page }) => {
  let name: string | undefined;

  try {
    // Create workflow
    const workflow = await createWorkflow(baseUrl, page.request);
    name = workflow.name as string;

    await page.goto(uiBaseUrl);

    // Click on "Workflows"
    const workflowsLink = page.getByRole("link", { name: "Workflows" });
    await workflowsLink.click();

    // Wait for table to appear
    await page.locator("#workflows-table").waitFor();

    const rows = page.locator("#workflows-table > tbody > tr");
    await expect(rows).toHaveCount(1);

    const firstRow = rows.first();
    const firstCell = firstRow.locator("td").first();
    const cellText = await firstCell.textContent();

    expect(cellText).toEqual(workflow.name);
  } finally {
    // Cleanup: delete the workflow if it was created
    if (name) {
      await deleteWorkflow(baseUrl, page.request, name);
    }
  }
});

test("non-empty jobs table", async ({ page }) => {
  let name: string | undefined;
  let jobId: string | undefined;

  try {
    // Create workflow
    const workflow = await createWorkflow(baseUrl, page.request);
    name = workflow.name as string;

    const job = await createJob(baseUrl, page.request, name);
    jobId = job.id as string;

    await page.goto(uiBaseUrl);

    // Wait for table to appear
    await page.locator("#jobs-table").waitFor();

    const rows = page.locator("#jobs-table > tbody > tr");
    await expect(rows).toHaveCount(1);

    const firstRow = rows.first();
    const firstCell = firstRow.locator("td").first();
    const cellText = await firstCell.textContent();

    expect(cellText).toEqual(jobId);
  } finally {
    // Cleanup (in reverse order)
    if (jobId) {
      await deleteJob(baseUrl, page.request, jobId);
    }
    if (name) {
      await deleteWorkflow(baseUrl, page.request, name);
    }
  }
});

test("job added to jobs table due to server-sent event", async ({ page }) => {
  let name: string | undefined;
  let jobId: string | undefined;

  try {
    await page.goto(uiBaseUrl);

    // Wait for table to appear
    await page.locator("#jobs-table").waitFor();
    await expect(page.locator("#jobs-table > tbody > tr")).toHaveCount(0);

    const workflow = await createWorkflow(baseUrl, page.request);
    name = workflow.name as string;

    const job = await createJob(baseUrl, page.request, name);
    jobId = job.id as string;

    // now job should be added to table due to job event sent by wfx
    const rows = page.locator("#jobs-table > tbody > tr");
    await expect(rows).toHaveCount(1);

    const firstRow = rows.first();
    const firstCell = firstRow.locator("td").first();
    const cellText = await firstCell.textContent();

    expect(cellText).toEqual(jobId);
  } finally {
    // Cleanup (in reverse order)
    if (jobId) {
      await deleteJob(baseUrl, page.request, jobId);
    }
    if (name) {
      await deleteWorkflow(baseUrl, page.request, name);
    }
  }
});

test("workflow details", async ({ page }) => {
  let name: string | undefined;

  try {
    // Create workflow
    const workflow = await createWorkflow(baseUrl, page.request);
    name = workflow.name as string;

    // Open workflow details page
    await page.goto(`${uiBaseUrl}/workflows/${name}`);

    // Check for SVG

    // Wait for <mermaid> to appear
    const mermaid = page.locator("mermaid");
    await mermaid.waitFor();

    // Check <svg> was generated by mermaid
    const svg = mermaid.locator("svg#graphDiv");
    await expect(svg).toBeVisible();

    const classAttr = await svg.getAttribute("class");
    expect(classAttr).toContain("statediagram");

    // Check workflow JSON is highlighted
    const codeBlock = page.locator("code#workflow-json");
    const stringSpans = codeBlock.locator("span.hljs-string");
    expect(await stringSpans.count()).toBeGreaterThan(0);
  } finally {
    // Cleanup: delete the workflow if it was created
    if (name) {
      await deleteWorkflow(baseUrl, page.request, name);
    }
  }
});

test("job details", async ({ page }) => {
  let name: string | undefined;
  let jobId: string | undefined;

  try {
    const workflow = await createWorkflow(baseUrl, page.request);
    name = workflow.name as string;

    const job = await createJob(baseUrl, page.request, name);
    jobId = job.id as string;

    // Open job details page
    await page.goto(`${uiBaseUrl}/jobs/${jobId}`);

    // Check for SVG

    // Wait for <mermaid> to appear
    const mermaid = page.locator("mermaid");
    await mermaid.waitFor();

    // Check <svg> was generated by mermaid
    const svg = mermaid.locator("svg#graphDiv");
    await expect(svg).toBeVisible();

    const classAttr = await svg.getAttribute("class");
    expect(classAttr).toContain("statediagram");

    // Check workflow JSON is highlighted
    const codeBlock = page.locator("code#job-json");
    const stringSpans = codeBlock.locator("span.hljs-string");
    expect(await stringSpans.count()).toBeGreaterThan(0);

    // Check job details
    const details = page.locator("table#job-details > tbody");
    await expect(
      details.locator('tr:has(td:text("Job ID")) td').nth(1),
    ).toHaveText(jobId);
    await expect(
      details.locator('tr:has(td:text("Client ID")) td').nth(1),
    ).toHaveText("rpi");
    await expect(
      details.locator('tr:has(td:text("State")) td').nth(1),
    ).toHaveText("INSTALL");
    await expect(
      details.locator('tr:has(td:text("Group")) td').nth(1),
    ).toHaveText("OPEN");
    await expect(
      details.locator('tr:has(td:text("Tags")) td').nth(1),
    ).toHaveText("");
    await expect(
      details.locator('tr:has(td:text("Created")) td').nth(1),
    ).toHaveText(formatDate(new Date(job.stime as string)));
    await expect(
      details.locator('tr:has(td:text("Modified")) td').nth(1),
    ).toHaveText(formatDate(new Date(job.mtime as string)));
  } finally {
    if (jobId) {
      await deleteJob(baseUrl, page.request, jobId);
    }
    if (name) {
      await deleteWorkflow(baseUrl, page.request, name);
    }
  }
});

function formatDate(date: Date): string {
  const pad = (n: number) => n.toString().padStart(2, "0");
  const month = pad(date.getMonth() + 1); // Months are 0-based
  const day = pad(date.getDate());
  const year = date.getFullYear();
  const hours = pad(date.getHours());
  const minutes = pad(date.getMinutes());
  const seconds = pad(date.getSeconds());
  return `${month}/${day}/${year} ${hours}:${minutes}:${seconds}`;
}
